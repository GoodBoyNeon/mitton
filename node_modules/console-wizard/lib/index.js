"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  WizardConfig: () => WizardConfig,
  logger: () => logger,
  setWizardConfig: () => setWizardConfig
});
module.exports = __toCommonJS(src_exports);

// src/helpers/combineParams.ts
var combineParams = (...args) => {
  return Array.from(args).join(" ");
};

// src/helpers/getLoggingArgs.ts
var statusText = {
  error: "ERROR ",
  warn: "WARN ",
  info: "INFO ",
  success: "SUCCESS "
};
var statusColors = {
  bg: {
    error: "bgRed",
    info: "bgBlue",
    success: "bgGreen",
    warn: "bgYellow"
  },
  fg: {
    error: "fgRed",
    info: "fgBlue",
    success: "fgGreen",
    warn: "fgYellow"
  }
};
var getLoggingArgs = (config, logData) => {
  const args = [`
`];
  const { includeTimestamp, includeStatus } = config;
  const { statusType } = logData;
  const statusMsg = statusText[statusType];
  const fgColor = statusColors.fg[statusType];
  const bgColor = statusColors.bg[statusType];
  if (includeTimestamp)
    args.push(...[styleWrapper["fgGray"], logData.timestamp, resetWrapper]);
  if (includeStatus)
    args.push(
      ...[
        styleWrapper[bgColor],
        styleWrapper["bold"],
        statusMsg,
        resetWrapper
      ]
    );
  args.push(...[styleWrapper[fgColor], logData.message, resetWrapper]);
  return args;
};

// src/helpers/getTimestamp.ts
var getTimestamp = () => {
  const time = convertTime((/* @__PURE__ */ new Date()).toLocaleTimeString());
  const date = (/* @__PURE__ */ new Date()).toLocaleDateString();
  return `${date} ${time}`;
};

// src/helpers/convertTime.ts
var convertTime = (time12h) => {
  const [time, modifier] = time12h.split(" ");
  if (!time || !modifier) {
    console.error("TimeString does not follow correct format.");
    return;
  }
  let [hours = "00", minutes, seconds] = time.split(":");
  if (hours === "12") {
    hours = "00";
  }
  if (modifier === "PM") {
    hours = (parseInt(hours, 10) + 12).toString();
  }
  return `${hours}:${minutes}:${seconds}`;
};

// src/helpers/styles.ts
var styleWrapper = {
  reset: "\x1B[0m",
  bold: "\x1B[1m",
  // This lightens the color as a side-effect
  dim: "\x1B[2m",
  italic: "\x1B[3m",
  underscore: "\x1B[4m",
  blink: "\x1B[5m",
  reverse: "\x1B[7m",
  hidden: "\x1B[8m",
  strike: "\x1B[9m",
  fgBlack: "\x1B[30m",
  fgRed: "\x1B[31m",
  fgGreen: "\x1B[32m",
  fgYellow: "\x1B[33m",
  fgBlue: "\x1B[34m",
  fgMagenta: "\x1B[35m",
  fgCyan: "\x1B[36m",
  fgWhite: "\x1B[37m",
  fgGray: "\x1B[90m",
  bgBlack: "\x1B[40m",
  bgRed: "\x1B[41m",
  bgGreen: "\x1B[42m",
  bgYellow: "\x1B[43m",
  bgBlue: "\x1B[44m",
  bgMagenta: "\x1B[45m",
  bgCyan: "\x1B[46m",
  bgWhite: "\x1B[47m",
  bgGray: "\x1B[100m"
};
var resetWrapper = "\x1B[0m";

// src/helpers/tableCharacters.ts
var defaultTableBorder = {
  cornerTL: "\u250C",
  cornerTR: "\u2510",
  cornerBL: "\u2514",
  cornerBR: "\u2518",
  edgeVertical: "\u2502",
  edgeHorizontal: "\u2500",
  intersectionTLR: "\u2534",
  intersectionBLR: "\u252C",
  intersectionTBL: "\u251C",
  intersectionTBR: "\u2524",
  intersectionCenter: "\u253C"
};

// src/setWizardConfig.ts
var defaultConfig = {
  includeTimestamp: true,
  includeStatus: true,
  tableBorder: defaultTableBorder,
  includeSN: false
};
var userConfig = defaultConfig;
var WizardConfig = class {
  constructor(config) {
    userConfig = __spreadValues(__spreadValues({}, defaultConfig), config);
    console.log("WARNING: `new WizardConfig()` is depreciated! Use `setWizardConfig()` instead.");
  }
};
var setWizardConfig = (config) => {
  userConfig = __spreadValues(__spreadValues({}, defaultConfig), config);
  return userConfig;
};

// src/helpers/getConfig.ts
var getConfig = (configOverride) => {
  return __spreadValues(__spreadValues({}, userConfig), configOverride);
};

// src/logger/error.ts
var timestamp = `[${getTimestamp()}]`;
var error = (message, userConfigOverride) => {
  const statusType = "error";
  const config = getConfig(userConfigOverride);
  const loggingArgs = getLoggingArgs(config, {
    statusType,
    message,
    timestamp
  });
  const args = combineParams(loggingArgs.join(" "));
  console.log(args);
  return message;
};

// src/logger/info.ts
var timestamp2 = `[${getTimestamp()}]`;
var info = (message, userConfigOverride) => {
  const statusType = "info";
  const config = getConfig(userConfigOverride);
  const loggingArgs = getLoggingArgs(config, {
    statusType,
    message,
    timestamp: timestamp2
  });
  const args = combineParams(loggingArgs.join(" "));
  console.log(args);
  return message;
};

// src/logger/success.ts
var timestamp3 = `[${getTimestamp()}]`;
var success = (message, userConfigOverride) => {
  const statusType = "success";
  const config = getConfig(userConfigOverride);
  const loggingArgs = getLoggingArgs(config, {
    statusType,
    message,
    timestamp: timestamp3
  });
  const args = combineParams(loggingArgs.join(" "));
  console.log(args);
  return message;
};

// src/logger/warn.ts
var timestamp4 = `[${getTimestamp()}]`;
var warn = (message, userConfigOverride) => {
  const statusType = "warn";
  const config = getConfig(userConfigOverride);
  const loggingArgs = getLoggingArgs(config, {
    statusType,
    message,
    timestamp: timestamp4
  });
  const args = combineParams(loggingArgs.join(" "));
  console.log(args);
  return message;
};

// src/helpers/filterDuplicates.ts
var filterDuplicates = (array) => {
  const uniqueValues = [];
  for (const row of array) {
    for (const value of row) {
      if (!uniqueValues.includes(value)) {
        uniqueValues.push(value);
      }
    }
  }
  return uniqueValues;
};

// src/helpers/capitalize.ts
var capitalize = (str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

// src/helpers/generateTable.ts
var getMaxLengths = (data, rows) => {
  return rows.map((row) => {
    const maxRowLength = row.length;
    const maxColumnLengths = data.map((item) => String(item[row]).length);
    return Math.max(maxRowLength, ...maxColumnLengths);
  });
};
var getKeyLengths = (data, keys) => {
  return keys.reduce((obj, key, i) => {
    var _a;
    obj[key] = (_a = getMaxLengths(data, keys)[i]) != null ? _a : 0;
    return obj;
  }, {});
};
var getValueLengths = (data, rows, values) => {
  const valueLengths = {};
  const columnMaxLengths = getMaxLengths(data, rows);
  values.forEach((elements) => {
    elements.forEach((element, i) => {
      if (!element)
        return;
      valueLengths[element] = columnMaxLengths[i] || 0;
    });
  });
  return valueLengths;
};
var generateTopRow = (data, topRowElements, values, config) => {
  const { tableBorder, includeSN } = config;
  if (!tableBorder) {
    throw new RangeError("tableBorder not found");
  }
  let row = `${tableBorder.cornerTL}`;
  const valuesLength = values.length;
  const snMaxLength = String(valuesLength).length < 3 ? 3 : String(valuesLength).length;
  if (includeSN) {
    row += tableBorder.edgeHorizontal.repeat(snMaxLength + 2);
    row += tableBorder.intersectionBLR;
  }
  const maxLengths = getMaxLengths(data, topRowElements);
  maxLengths.forEach((length) => {
    row += `${tableBorder.edgeHorizontal.repeat(length + 2)}${tableBorder.intersectionBLR}`;
  });
  row = row.slice(0, -1) + `${tableBorder.cornerTR}
`;
  row += `${tableBorder.edgeVertical}`;
  if (includeSN) {
    row += ` ${styleWrapper.bold}S.N${resetWrapper} ${" ".repeat(snMaxLength - 3)}`;
    row += tableBorder.edgeVertical;
  }
  const elementLengths = getKeyLengths(data, topRowElements);
  topRowElements.forEach((element) => {
    const rowTotalLength = elementLengths[element];
    if (!rowTotalLength)
      return;
    const noSpaces = rowTotalLength - element.length;
    row += ` ${styleWrapper.bold}${capitalize(element)}${resetWrapper}${" ".repeat(noSpaces + 1)}`;
    row += tableBorder.edgeVertical;
  });
  row += `
${tableBorder.intersectionTBL}`;
  if (includeSN) {
    row += tableBorder.edgeHorizontal.repeat(snMaxLength + 2);
    row += tableBorder.intersectionCenter;
  }
  topRowElements.forEach((element) => {
    const rowTotalLength = elementLengths[element] || 0;
    row += `${tableBorder.edgeHorizontal.repeat(rowTotalLength + 2)}${tableBorder.intersectionCenter}`;
  });
  row = row.slice(0, -1) + `${tableBorder.intersectionTBR}`;
  row += "\n";
  return row;
};
var generateBody = (data, rows, bodyElements, config) => {
  let body = "";
  const { tableBorder, includeSN } = config;
  if (!tableBorder)
    return;
  const valuesLength = bodyElements.length;
  const snMaxLength = String(valuesLength).length < 3 ? 3 : String(valuesLength).length;
  bodyElements.forEach((elements, i) => {
    const columnLengths = getValueLengths(data, rows, bodyElements);
    if (includeSN) {
      body += `${tableBorder.edgeVertical} ${i + 1}${" ".repeat(
        snMaxLength - String(i + 1).length + 1
      )}`;
    }
    body += `${tableBorder.edgeVertical} `;
    elements.forEach((column) => {
      if (!column)
        return;
      const rowTotalLength = columnLengths[column] || 0;
      let columnLength = 0;
      if (typeof column === "string")
        columnLength = column.length;
      if (typeof column === "number")
        columnLength = column.toString().length;
      const noSpaces = rowTotalLength + 1 - columnLength;
      body += `${column}${" ".repeat(noSpaces)}${tableBorder.edgeVertical} `;
    });
    body += `
${tableBorder.intersectionTBL}`;
    if (includeSN) {
      body += `${tableBorder.edgeHorizontal.repeat(snMaxLength + 2)}`;
      body += tableBorder.intersectionCenter;
    }
    elements.forEach((column) => {
      if (!column)
        return;
      const rowTotalLength = columnLengths[column] || 0;
      body += `${tableBorder.edgeHorizontal.repeat(rowTotalLength + 2)}${tableBorder.intersectionCenter}`;
    });
    body = body.slice(0, -1) + `${tableBorder.intersectionTBR} 
`;
  });
  body = body.slice(0, -2);
  body = body.substring(0, body.lastIndexOf("\n"));
  body += "\n";
  return body;
};
var generateEndBorder = (data, topRowELements, values, config) => {
  const { tableBorder, includeSN } = config;
  if (!tableBorder)
    return;
  const columnLengths = getMaxLengths(data, topRowELements);
  const valuesLength = values.length;
  const snMaxLength = String(valuesLength).length < 3 ? 3 : String(valuesLength).length;
  let border = "";
  border += tableBorder.cornerBL;
  if (includeSN) {
    border += `${tableBorder.edgeHorizontal.repeat(snMaxLength + 2)}`;
    border += tableBorder.intersectionTLR;
  }
  columnLengths.forEach((length) => {
    border += tableBorder.edgeHorizontal.repeat(length + 2) + tableBorder.intersectionTLR;
  });
  border = border.slice(0, -1) + tableBorder.cornerBR;
  border += "\n";
  return border;
};
var generateTable = (data, configOverride) => {
  let table2 = "";
  const config = getConfig(configOverride);
  const { tableBorder } = config;
  if (!tableBorder) {
    throw new RangeError("tableBorder is not defined");
  }
  const keys = data.map((dataObj) => Object.keys(dataObj));
  const values = data.map((dataObj) => Object.values(dataObj));
  const topRowElements = filterDuplicates(keys);
  console.log(keys);
  console.log(values);
  table2 += generateTopRow(data, topRowElements, values, config);
  table2 += generateBody(data, topRowElements, values, config);
  table2 += generateEndBorder(data, topRowElements, values, config);
  return table2;
};

// src/logger/table.ts
var table = (data, configOverride) => {
  const table2 = generateTable(data, configOverride);
  console.log(table2);
};

// src/index.ts
var logger = {
  error,
  info,
  success,
  warn,
  table
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  WizardConfig,
  logger,
  setWizardConfig
});
